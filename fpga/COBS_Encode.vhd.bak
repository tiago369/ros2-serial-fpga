library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity COBS_Encode is
    generic (
        MAX_FRAME_SIZE : integer := 255  -- Maximum size of the input vector
    );
    port (
        clk       : in  std_logic;                            -- Clock signal
        reset     : in  std_logic;                            -- Reset signal
        data_in   : in  std_logic_vector(MAX_FRAME_SIZE-1 downto 0);  -- Input data vector
        encoded   : out std_logic_vector((MAX_FRAME_SIZE+8) downto 0);  -- Encoded output vector
        encoded_length : out integer range 0 to MAX_FRAME_SIZE+1  -- Length of the encoded frame
    );
end COBS_Encode;

architecture rtl of COBS_Encode is
    signal idx       : integer range 0 to MAX_FRAME_SIZE := 0;
    signal count     : integer range 0 to MAX_FRAME_SIZE := 0;
    signal stuffing  : std_logic := '0';
begin
    process (clk)
    begin
        if rising_edge(clk) then
            if reset = '1' then
                idx <= 0;
                count <= 1;
                stuffing <= '0';
                encoded_length <= 1;
            else
                if count = MAX_FRAME_SIZE then
                    encoded(idx) <= std_logic(count);
                    idx <= idx + 1;
                    count <= 1;
                    stuffing <= '1';
                elsif data_in(count-1) = '0' and stuffing = '0' then
                    encoded(idx) <= std_logic(count);
                    idx <= idx + 1;
                    count <= 1;
                else
                    encoded(idx) <= data_in(count-1);
                    idx <= idx + 1;
                    count <= count + 1;
                    if count = MAX_FRAME_SIZE then
                        encoded_length <= idx;
                    end if;
                    stuffing <= '0';
                end if;
            end if;
        end if;
    end process;

    encoded(0) <= '0';
end rtl;
